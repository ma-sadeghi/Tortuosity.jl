var documenterSearchIndex = {"docs":
[{"location":"taufactor/#Why-not-TauFactor?","page":"Why not TauFactor?","title":"Why not TauFactor?","text":"","category":"section"},{"location":"taufactor/","page":"Why not TauFactor?","title":"Why not TauFactor?","text":"For the most part, taufactor is a great package to compute the tortuosity factor of porous media. However, it has two main drawbacks, which are addressed by Tortuosity.jl:","category":"page"},{"location":"taufactor/#Inaccurate-concentration-field","page":"Why not TauFactor?","title":"Inaccurate concentration field","text":"","category":"section"},{"location":"taufactor/","page":"Why not TauFactor?","title":"Why not TauFactor?","text":"First, taufactor doesn't properly solve the Laplace equation. Instead, it solves it enough such that the inlet and outlet fluxes match to a prescribed precision. This is not a problem per se, but it can lead to inaccurate results especially when there's strong heterogeneity in the medium (or more technically, when the size of the image is comparable to the representative elementary volume). Also, even when the computed tortuosity factor is accurate, the concentration field is not guaranteed to be accurate.","category":"page"},{"location":"taufactor/#Sparse-vs.-matrix-representation","page":"Why not TauFactor?","title":"Sparse vs. matrix representation","text":"","category":"section"},{"location":"taufactor/","page":"Why not TauFactor?","title":"Why not TauFactor?","text":"Second, while taufactor is GPU-accelerated, it always considers the entire image as the working domain. This is not a problem when porosity (i.e,. void fraction) is high and close to 1, but it starts to slow down the computation at lower porosities. In contrast, Tortuosity.jl only considers the void space, which can lead to significant speedups up to 5x at low porosities.","category":"page"},{"location":"taufactor/","page":"Why not TauFactor?","title":"Why not TauFactor?","text":"That being said, taufactor is a great package and has been an inspiration for Tortuosity.jl!","category":"page"},{"location":"Imaginator/#Imaginator.jl","page":"Imaginator.jl","title":"Imaginator.jl","text":"","category":"section"},{"location":"Imaginator/","page":"Imaginator.jl","title":"Imaginator.jl","text":"Imaginator.jl is a submodule within Tortuosity.jl to generate synthetic 3D voxel images of porous media plus some utilities to manipulate them. The main goal of Imaginator.jl is to provide a simple way to generate 3D images of porous media for testing and benchmarking purposes. If you're familiar with the PoreSpy package in Python, you can think of Imaginator.jl as a stripped-down generators module in PoreSpy.","category":"page"},{"location":"Imaginator/#Example-usage","page":"Imaginator.jl","title":"Example usage","text":"","category":"section"},{"location":"Imaginator/","page":"Imaginator.jl","title":"Imaginator.jl","text":"using Tortuosity: Imaginator\n\nimg = Imaginator.blobs(shape=(100, 100, 100), porosity=0.4, blobiness=1.5)\neps = Imaginator.phase_fraction(img)\n@info \"Phase fraction: $eps\"\n\n# Remove non-percolating paths along the x-axis\nimg = Imaginator.trim_nonpercolating_paths(img, axis=:x)\neps = Imaginator.phase_fraction(img)\n@info \"Phase fraction after trimming: $eps\"","category":"page"},{"location":"benchmark/#Comparision-to-other-libraries","page":"Comparision to other libraries","title":"Comparision to other libraries","text":"","category":"section"},{"location":"benchmark/","page":"Comparision to other libraries","title":"Comparision to other libraries","text":"The following benchmarks compare the performance of Tortuosity.jl to other popular libraries, namely, taufactor and PuMA.","category":"page"},{"location":"#Tortuosity.jl","page":"Tortuosity.jl","title":"Tortuosity.jl","text":"","category":"section"},{"location":"","page":"Tortuosity.jl","title":"Tortuosity.jl","text":"Tortuosity.jl is a GPU-accelerated solver to compute the tortuosity factor (tau) of voxel images of porous media. You can think of Tortuosity.jl as the equivalent of TauFactor toolbox in MATLAB, or taufactor in Python, but faster and more reliable.","category":"page"},{"location":"#Installation","page":"Tortuosity.jl","title":"Installation","text":"","category":"section"},{"location":"","page":"Tortuosity.jl","title":"Tortuosity.jl","text":"To install Tortuosity.jl, simply run the following command in the Julia REPL:","category":"page"},{"location":"","page":"Tortuosity.jl","title":"Tortuosity.jl","text":"using Pkg\nPkg.add(\"Tortuosity\")","category":"page"},{"location":"#Basic-usage","page":"Tortuosity.jl","title":"Basic usage","text":"","category":"section"},{"location":"","page":"Tortuosity.jl","title":"Tortuosity.jl","text":"To compute the tortuosity factor of a voxel image, you can use the following workflow:","category":"page"},{"location":"","page":"Tortuosity.jl","title":"Tortuosity.jl","text":"using Tortuosity\nusing Tortuosity: TortuositySimulation, tortuosity, vec_to_grid\nusing Tortuosity: Imaginator\n\nusing CUDA  # Optional, for GPU acceleration\nusing LinearSolve\n\n# Create a random 3D voxel image using Gaussian noise\nimg = Imaginator.blobs(shape=(100, 100, 100), porosity=0.4, blobiness=1.5)\n\n# Compute the tortuosity factor\nsim = TortuositySimulation(img; axis=:x, gpu=true);\nsol = solve(sim.prob, KrylovJL_CG(); verbose=false, reltol=1e-5);\nc_grid = vec_to_grid(sol.u, img)  # Convert the solution vector to a grid\nτ = tortuosity(c_grid, :x)\n@info \"Tortuosity factor: $τ\"","category":"page"}]
}
